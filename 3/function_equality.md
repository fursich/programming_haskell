## 3.11 (5) 関数の同等性

#### 同等であることがプログラム的に決定しえない理由

* 関数の表現は無数にあるため...？
(for |x| < 1)
1/(1-x) == 1/{(1-sprt(x))(1 + sqrt(x))} == Σ x^n (n=0..infinity) == d(log(x-1))/dx

少なくとも型と簡約化・変数の照合といった、外形上の特徴だけで同じ関数であることを証明することが難しそう

参考：同値性の決定不可能性
https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97#%E5%90%8C%E5%80%A4%E6%80%A7%E3%81%AE%E6%B1%BA%E5%AE%9A%E4%B8%8D%E5%8F%AF%E8%83%BD%E6%80%A7

#### 同値性が定義できる関数の部分集合（クラス）

以下のような関数のサブクラス内に限定すると、同値関係の定義は可能そう

* 恒等関数のクラスの場合

{ f | f = c }

f == f' <=> c == c'

* 有限な要素を持つ型上の全域関数のクラス

  - 例えばBool × Bool -> Intの場合

    { f | f :: Bool -> Bool -> Int }

f == f' <=> for∀ x, y ∈ Bool x Bool => f(x,y) == f'(x,y)

ただし定義域の型が取りうる要素数をn、引数の数をarとすると、同値関係の決定にはn^ar通りの検証が発生する

（たとえばInt型の引数を５種類とるような関数の同値関係の決定は現実的な計算量にならないと思われる）
